#!/bin/bash
# .bashrc
# ~/menuapp/doc/bashrc-advanced
# shellcheck disable=SC2155
# shellcheck source=/dev/null
#
IFS="
"
# This sample bashrc almost certainly contains settings that
# are not appropriate for your system. It is provided as a
# reference only. You should carefully review and modify
# this file to suit your specific needs and environment.
# Do NOT blindly copy this file to your system.
#
# Make sure you understand what each setting does
# before using it.
#
# It is recommended to back up your existing .bashrc
# before replacing it with this sample.
# Use at your own risk.
#   ╭───────────────────────────────────────────────────────────────╮
#   │ SET UP SHELL STARTUP LOGGING                                  │
#   ╰───────────────────────────────────────────────────────────────╯
# To activate shell startup logging, create a file named
# .shelllog in your home directory.
# Each time a shell starts, it will append a log entry
# to /var/log/shell.log
export BASHRC=1
unset BASHLOG
unset GH_TOKEN
if [ -f "$HOME"/.shelllog ]; then
	export BASHLOG="1"
fi
this_file="$HOME"/.bashrc
ShellLog() { echo "$(rfc3339)" "$this_file" "$1" >>/var/log/shell.log; }
#   ╭───────────────────────────────────────────────────────────────╮
#   │ PREPEND_PATH                                                  │
#   ╰───────────────────────────────────────────────────────────────╯
# This technique for managing the PATH environment variable is from
# bashfaq #24. It's elegant and efficient.
# Usage: prepend_path /some/directory
#
# It checks if the directory is already in PATH. If not, it
# prepends it to PATH.
#
prepend_path() {
	case ":${PATH}:" in
	*:"$1":*) ;;
	*)
		PATH="$1:$PATH"
		;;
	esac
}
# @WARNING: /usr/bin/view is generally a link to vim, which will
# obscure C-Menu View if /usr/bin preceedes $HOME/menuapp/bin
# in your PATH environment variable.
#
# If you have issues starting C-Menu View by typing "view" at
# the shell prompt, examine your PATH environment variable.
#
export PATH=/usr/bin:/bin:/usr/sbin:/sbin
[ -d "/usr/lib/qt6/bin" ] && prepend_path "/usr/lib/qt6/bin"
[ -d "/usr/local/bin" ] && prepend_path "/usr/local/bin"
[ -d "$HOME/.local/bin" ] && prepend_path "$HOME/.local/bin"
[ -d "$HOME/.cargo/bin" ] && prepend_path "$HOME/.cargo/bin"
[ -d "$HOME/menuapp/bin" ] && prepend_path "$HOME/menuapp/bin"
export PATH
# alternatively
# . "$HOME"/menuapp/bin/cmenu-bashrc
# or
# [ -d "$HOME/menuapp/bin" ] && prepend_path "$HOME/menuapp/bin"
#   ╭───────────────────────────────────────────────────────────────╮
#   │ C-MENU Environment Variables                                  │
#   ╰───────────────────────────────────────────────────────────────╯
#   C-Menu requires that its executables be in your PATH.
#   This is handled above by prepending $HOME/menuapp/bin to PATH.
#   It is a very small directory, so there is little downside to
#   having it early in your PATH.
#   Already set above by the following line:
#   [ -d "$HOME/menuapp/bin" ] && prepend_path "$HOME/menuapp/bin"
export CMENU_SRC=/usr/local/src/cmenu/src
export CMENU_HOME="$HOME"/menuapp
#   ╭───────────────────────────────────────────────────────────────╮
#   │ ALTERNATE SHELL NAME                                          │
#   ╰───────────────────────────────────────────────────────────────╯
#   Adhering to the principle of "security through obscurity", having
#   a shell with an obscure name can be beneficial.
#
#   using xsh, or some other alias reduces visibility and
#   vulnerability to some automated attacks and "jerkware".
#
#   Jerkware are automated scripts that target common shell names
#   like bash, sh, zsh, ksh, etc. By using an obscure shell name,
#   you can reduce the likelihood of being targeted by such scripts.
#
#   You can just copy /bin/bash to /bin/xsh. A symbolic link would
#   would defeat the purpose.
#
#   Building your shell from source is highly reccommended.
#   However, you must make the same libraries used in your build,
#   especially, Ncurses, tinfo, and readline available at runtime,
#   and make sure your custom version of bash will use those libraries.
#   If you do that, you can make backup copies of your original
#   bash and bashbug and install your custom bash.
#
#   Once you have your xsh binary, place it somewhere in your PATH,
#   then this line will set your SHELL variable to xsh.
#   Leave "export SHELL=BASH" as a fallback. If xsh isn't available,
#   you will still have a working shell and Nothing works without a shell.
#
export SHELL=bash
which xsh >/dev/null 2>&1 && export SHELL=xsh
#   ╭───────────────────────────────────────────────────────────────╮
#   │ RSH                                                           │
#   ╰───────────────────────────────────────────────────────────────╯
# rsh is a small C program that provides a root shell to
# non-privileged users. It is intended for personal systems
# where you are the only user, or where you trust all users.
#
# It is NOT intended for multi-user systems where security
# is a concern.
#
# rsh works by being installed as a setuid root binary.
# When a non-privileged user runs rsh, it spawns a root shell.
#
# To exit the root shell, simply type "exit", press Ctrl-D, or,
# if you have a function like "x" below, just type "x".
#
# Once rsh and the following functions are installed, you can,
# from a standard user shell, type "xx" to start a root shell,
# and "x" to exit that root shell.
#   ╭───────────────────────────────────────────────────────────────╮
#   │ XX and X                                                      │
#   ╰───────────────────────────────────────────────────────────────╯
#   xx and x are convenience functions for starting and
#   exiting a root shell using rsh.
xx() {
	if file "$HOME"/menuapp/bin/rsh | grep setuid >/dev/null 2>&1; then
		"$HOME"/menuapp/bin/rsh
	else
		if file /usr/local/bin/rsh | grep setuid >/dev/null 2>&1; then
			/usr/local/bin/rsh
		fi
	fi
}
# Using the following function allows you to exit the root shell
# instantiated by the above function by typing "x".
#
# As an added benefit, it directs the output of exit to /dev/null,
# which suppresses the annoying "exit" message that adds another
# non-relevant line to your terminal.
#
# This is especially useful when you have nested shells and want
# to exit multiple levels without cluttering the terminal with
# exit messages.
x() { exit >/dev/null 2>&1; }
#   ╭───────────────────────────────────────────────────────────────╮
#   │ SHELL PROMPT WITH ELEVATED PRIVILEGE INDICATOR                │
#   ╰───────────────────────────────────────────────────────────────╯
# A green prompt for normal users, red for root.
# You can customize this prompt or use whatever prompt you like,
# but an obvious indicator of privilege level is highly recommended.
export PS1="\[\e[1;32m\]\u@\h(\l)\w->\[\e[0m\] "
export XUSER="$(id -un)"
[ "$XUSER" = "root" ] && export PS1="\[\e[1;31m\]\u@\h(\l)\w->\[\e[0m\] "
#   ╭───────────────────────────────────────────────────────────────╮
#   │ MISCELANEOUS CONVENIENCE FUNCTIONS                            │
#   ╰───────────────────────────────────────────────────────────────╯
# setup inferior tty for gdb sessions
# useful when debugging programs that require user input
which sleep >/dev/null 2>&1 && s() {
	TTY=$(tty)
	/bin/grep -v "inferior-tty" "$HOME"/.gdbinit >/tmp/.gdbinit.$$ 2>&1
	echo "set inferior-tty $TTY" >>/tmp/.gdbinit.$$
	mv /tmp/.gdbinit.$$ "$HOME"/.gdbinit
	#   clear
	echo "sleeping"
	sleep 50000
}
which gdb >/dev/null 2>&1 && gdb() { /usr/bin/gdb --silent "$@"; }
which nvim >/dev/null 2>&1 && vi() { nvim "$@"; }
which grep >/dev/null 2>&1 && grep() { /usr/bin/grep -Hn "$@"; }
# typing mm takes less time than menu if you use it often
# You must prepend $HOME/menuapp/bin to your PATH before the following
# the following function is defined.
. "$HOME"/menuapp/bin/cmenu_path
which menu >/dev/null 2>&1 && mm() {
	menu "$@"
}
kk() { cd /usr/local/src/cmenu/src || return; }
#   ╭───────────────────────────────────────────────────────────────╮
#   │ SETUP LSD PREFERENCE OVER LS                                  │
#   ╰───────────────────────────────────────────────────────────────╯
PREFER_LSD=1
if [ "$PREFER_LSD" = "1" ]; then
	which lsd >/dev/null 2>&1 && ls() { /usr/bin/lsd "$@"; }
else
	which ls >/dev/null 2>&1 && ls() { /bin/ls --color=auto "$@"; }
fi
Man() {
	man -Tutf8 "$@" | sed -f ~/menuapp/msrc/man.sed | view
}
export MANPAGER="nvim +Man!"
export MANWIDTH=200
#   ╭───────────────────────────────────────────────────────────────╮
#   │ TERMINAL SETUP                                                │
#   ╰───────────────────────────────────────────────────────────────╯
export TERM=xterm-256color
export TTYPATH=/dev/pts
export EDITOR=nvim
clear() {
	tput clear
}
stty ixany
set -o vi
#   ╭───────────────────────────────────────────────────────────────╮
#   │ CURSES                                                        │
#   ╰───────────────────────────────────────────────────────────────╯
# A delay of 50 may cause problems with slow connections. The default
# is 1000 milliseconds. Adjust as needed.
# Some terminals may require a higher value to function properly.
# If you experience issues with key sequences not being recognized,
# try increasing the value.
# 200 is a good compromise between responsiveness and reliability.
# 50 is more responsive on fast local terminals.
# You can experiment with different values to find the best
# setting for your environment.
export ESCDELAY=200
export ESCDELAY=50
#   ╭───────────────────────────────────────────────────────────────╮
#   │ OPTIONAL SETTINGS - SYSTEM SPECIFIC                           │
#   ╰───────────────────────────────────────────────────────────────╯
export PAGER=$(which view 2>/dev/null)
export MANPAGER="nvim +Man!"
export MANWIDTH=80
export COB_CONFIG_DIR=/usr/share/gnucobol/config
export LPDEST="$HOME"/prtout
export QT_STYLE_OVERRIDE=gtk
export PKG_CONFIG_PATH=/usr/lib64/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig:/usr/local/lib/pkgconfig:/usr/local/lib64/pkgconfig
export JAVA_HOME=/usr/lib64/jvm/java-21-openjdk-21
export NODE_PATH="$HOME"/node_modules
export python3_host_prog=/usr/bin/python3
export XDG_CONFIG_HOME="$HOME"/.config
export XDG_DATA_HOME="$HOME"/.local/share
export CARGO_HOME="$HOME"/.cargo
export RUSTUP_HOME="$HOME"/.rustup
export LLVM_LIB_DIR=/usr/lib64
export MASON="$HOME/.local/share/lazyvim/mason"
export QML_IMPORT_PATH=/usr/lib64/qt6/qml
if [ "$BASHLOG" ]; then
	if [ ! -w /var/log/shell.log ]; then
		echo "error: /var/log/shell.log is not writable by $USER"
	else
		ShellLog "--------------------------------"
		ShellLog "TERM=$TERM"
		ShellLog "USER=$USER"
		ShellLog "XUSER=$XUSER"
		ShellLog "LOGNAME=$LOGNAME"
		ShellLog "HOME=$HOME"
		ShellLog "XPWD=$XPWD"
	fi
fi
. "$HOME/.cargo/env"
