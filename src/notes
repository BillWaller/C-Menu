


view->buf_curr_ptr - points to the next character to be read or written in the current buffer
view->buf_end_ptr  - points to the end of the current buffer

// Example usage:
char *current_char = *(view->buf_curr_ptr); // Get the current character
char *end_char = *(view->buf_end_ptr);       // Get the end character

// To read characters until the end of the buffer
while (*(view->buf_curr_ptr) < *(view->buf_end_ptr)) {
    char c = **(view->buf_curr_ptr);
    // Process character c
    (*(view->buf_curr_ptr))++; // Move to the next character
}

// To read in reverse until the start of the buffer
while (*(view->buf_curr_ptr) > buffer_start) {
    (*(view->buf_curr_ptr))--; // Move to the previous character
    char c = **(view->buf_curr_ptr);
    // Process character c
}

Assuming each line ends with a '\n', view->buf_curr_ptr doesn't stop advancing
until it has read the '\n' at the end of each line. It is therefore positioned
just after the '\n' when the end of the line is reached.

In reverse reading, view->buf_curr_ptr is positioned just before the '\n' at the end
of each line when the start of the line is reached.

However, with a pager-type application, it seems more convenient for view->buf_curr_ptr
to be positioned at the '\n' character itself when the end of the line is reached
during forward reading, and similarly at the '\n' character when the start of the line
is reached during reverse reading. Does this make sense?

Yes, it makes sense to adjust the behavior of `view->buf_curr_ptr` to point to the newline character (`'\n'`) when reaching the end of a line during forward reading, and similarly to point to the newline character when reaching the start of a line during reverse reading. This approach can enhance the usability of a pager-type application by making it easier to identify line boundaries.

